# Merge new files
Add silent sound to video generated by WAN21
 ffmpeg -i "w2_00173.mp4" -f lavfi -i aevalsrc=0 -shortest -y "new_w2_00173.mp4"

Merge videos with sound
./gemini.bash ./output/MERGED/

Gemini Bash
#!/bin/bash

# This script concatenates all video files in a specified directory.
#
# It standardizes all video and audio streams to ensure compatibility,
# which is a more robust method for preventing errors. It handles videos
# both with and without audio by adding a silent track to the latter.
# This ensures the final concatenated video has a continuous audio stream
# and smooth seeking.
#
# Usage: ./concat_videos.sh /path/to/your/videos

# --- Configuration ---
# Supported video file extensions (add or remove as needed)
VIDEO_EXTENSIONS=("mp4" "mov" "mkv" "avi" "flv" "webm")
# Name for the final output file
OUTPUT_FILENAME="output.mp4"
# --- Standardization Settings ---
# Set a standard resolution, frame rate, and pixel format for all videos.
# This ensures all temporary files are identical for concatenation.
TARGET_WIDTH="480"
TARGET_HEIGHT="832"
TARGET_FRAMERATE="30"
TARGET_PIXEL_FORMAT="yuv420p"
TARGET_AUDIO_CODEC="aac"
TARGET_AUDIO_SAMPLERATE="44100"
TARGET_AUDIO_CHANNELS="2"


# --- Main Script Logic ---

# Check for required commands
if ! command -v ffmpeg &> /dev/null || ! command -v ffprobe &> /dev/null; then
    echo "Error: ffmpeg and ffprobe are required but could not be found."
    echo "Please install ffmpeg on your system."
    exit 1
fi

# Check if a directory was provided as an argument
if [ -z "$1" ]; then
    echo "Usage: $0 <directory>"
    exit 1
fi

TARGET_DIR="$1"

# Check if the provided directory exists
if [ ! -d "$TARGET_DIR" ]; then
    echo "Error: Directory '$TARGET_DIR' not found."
    exit 1
fi

# Navigate to the target directory or exit if it fails
cd "$TARGET_DIR" || exit

# Create a temporary directory for processed files
TEMP_DIR="temp_processed"
mkdir -p "$TEMP_DIR"

echo "--- Processing all video files in a single pass ---"
# Process all files in a single loop for clarity and robustness.
find . -maxdepth 1 -type f | sort -V | while read -r f; do
    # Skip our own output file to prevent recursion
    if [ "$(basename "$f")" == "$OUTPUT_FILENAME" ]; then
        continue
    fi

    # Check if the file is a regular file and has a supported extension
    if [ -f "$f" ]; then
        # Convert extension to lowercase for case-insensitive matching
        extension="${f##*.}"
        extension_lower="${extension,,}"
        is_supported=false
        for ext in "${VIDEO_EXTENSIONS[@]}"; do
            if [[ "$extension_lower" == "$ext" ]]; then
                is_supported=true
                break
            fi
        done

        if [ "$is_supported" = true ]; then
            echo "----------------------------------------"
            echo "Checking file: $f"
            # Check if the video has an audio stream
            ffprobe -v error -select_streams a:0 -show_entries stream=codec_type -of csv=p=0 "$f" > /dev/null 2>&1
            HAS_AUDIO=$?
            
            PROCESSED_FILE_PATH="$TEMP_DIR/$(basename "${f%.*}").mp4"
            VIDEO_FILTER="scale=${TARGET_WIDTH}:${TARGET_HEIGHT}:force_original_aspect_ratio=decrease,pad=${TARGET_WIDTH}:${TARGET_HEIGHT}:(ow-iw)/2:(oh-ih)/2:color=black,fps=${TARGET_FRAMERATE},format=${TARGET_PIXEL_FORMAT}"

            if [ $HAS_AUDIO -eq 0 ]; then
                # This file has audio.
                echo "-> Found audio. Standardizing video and audio."
                # Re-encode both video and audio to the standard format.
                ffmpeg -y -i "$f" -vf "$VIDEO_FILTER" -c:v libx264 -c:a ${TARGET_AUDIO_CODEC} -ar ${TARGET_AUDIO_SAMPLERATE} -ac ${TARGET_AUDIO_CHANNELS} "$PROCESSED_FILE_PATH"
                echo "-> Ready for concatenation."

            elif [ $HAS_AUDIO -eq 1 ]; then
                # This file does NOT have audio.
                echo "-> No audio stream detected. Adding silent audio."
                # Get the exact duration of the video stream.
                DURATION=$(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "$f")
                
                # Create a temporary file with silent audio of the exact same duration as the video.
                ffmpeg -y -i "$f" \
                    -filter_complex "[0:v]${VIDEO_FILTER}[vout];aevalsrc=0:channel_layout=stereo:sample_rate=${TARGET_AUDIO_SAMPLERATE}:d=${DURATION}[aout]" \
                    -map "[vout]" -map "[aout]" \
                    -c:v libx264 \
                    -c:a ${TARGET_AUDIO_CODEC} \
                    "$PROCESSED_FILE_PATH"
                echo "-> Ready for concatenation."
            else
                # ffprobe failed for another reason (e.g., corrupted file)
                echo "-> Skipping file (could not read with ffprobe): $f"
            fi
        else
            echo "-> Skipping file (unsupported extension): $f"
        fi
    fi
done

echo "----------------------------------------"

# --- Final Concatenation using concat demuxer ---

CONCAT_LIST_FILE="mylist.txt"
> "$CONCAT_LIST_FILE" # Clear the file if it already exists

# Find all processed files and write them to the list file.
# Using `find` and `sort -V` again to ensure order is maintained.
find "$TEMP_DIR" -name '*.mp4' | sort -V | while read -r file; do
    # The file path needs to be quoted for ffmpeg's concat demuxer.
    echo "file '$(realpath "$file")'" >> "$CONCAT_LIST_FILE"
done

# Check if any videos were found and processed
if ! [ -s "$CONCAT_LIST_FILE" ]; then
    echo "No video files found to concatenate in '$TARGET_DIR'."
    rm -r "$TEMP_DIR"
    exit 0
fi

echo "All videos processed. Starting final concatenation using the concat demuxer and re-encoding..."

# Concatenate all the processed files from the list by RE-ENCODING them.
# This is the most robust method. It avoids issues from metadata
# inconsistencies by building a completely new file, rather than just copying streams.
ffmpeg -y -f concat -safe 0 -i "$CONCAT_LIST_FILE" -c:v libx264 -c:a aac -movflags +faststart "$OUTPUT_FILENAME"

# --- Cleanup ---
echo "Cleaning up temporary files..."
rm -r "$TEMP_DIR"
rm "$CONCAT_LIST_FILE"

echo "----------------------------------------"
echo "Concatenation complete! Output file is: $TARGET_DIR/$OUTPUT_FILENAME"

